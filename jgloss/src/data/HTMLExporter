<!-- start of JGloss embedded file -->
<!--
Written by Michael Koch (tensberg@gmx.net)

Original character encoding: UTF-8

The content of this file (everything between
- start of JGloss embedded file - and - end of JGloss embedded file -) is embedded
in the HTML document when a JGloss document is exported via the HTMLExporter.

The content of this data file is public domain and comes with no warranties. Do with it
whatever you want.

$Id$
-->

<STYLE type="text/css">
<!--
span.an { cursor: pointer; }
ruby, rbc, rtc, rb, rt { display: inline; }
rt.re { ruby-position: before; }
rt.tr { ruby-position: after; }
div.popup { display: none; position: absolute; left: 0px; top: 0px; 
            font-size: 70%; background-color: yellow; }
//-->
</STYLE>

<SCRIPT language="javascript">
<!--
// The scripts have to handle three cases: browsers which understand the <ruby> element, browsers
// which don't understand <ruby> but don't throw away unknown tags (in both cases the "display"
// style attribute will be used to show/hide annotations) and browsers which will throw
// away all unkown tags (in this case annotations will be stored as an element attribute and nodes will
// will be added/removed as to show/hide the annotations).

// If the browser knows how to display the <ruby> element, we will always display reading
// annotations.
var rubySupported = false;

var reading_popup;
var reading_popup_text;
var translation_popup;
var translation_popup_text;

function setupDoc( backwardsCompatible, interactive) {
    reading_popup = document.getElementById( "reading-popup");
    if (reading_popup) {
        for ( j=0; j<reading_popup.childNodes.length; j++) {
            reading_popup_text = reading_popup.childNodes[j];
            if (reading_popup_text.nodeType == 3)
                break;
        }
    }
    translation_popup = document.getElementById( "translation-popup");
    if (translation_popup) {
        for ( j=0; j<translation_popup.childNodes.length; j++) {
            translation_popup_text = translation_popup.childNodes[j];
            if (translation_popup_text.nodeType == 3)
                break;
        }
    }

    if (document.getElementsByTagName) {
        // all hope is lost for browsers which don't support DOM Level 1

        // hide all annotations (if needed with this browser)
        var rts = document.getElementsByTagName( "rt");
        if (rts.length != 0) {
            // This browser supports <rt> tags (Internet Explorer 5)
            // or does not throw away unrecognized tags (Mozilla).
            // In the former case, we remove the annotation parentheses,
            // in the latter we hide the tags and add parentheses if not backwardsCompatible.
            if (navigator.userAgent.search(/MSIE/)!=-1) {
                rubySupported = true;
                if (backwardsCompatible || interactive) {
                    for ( i=0; i<rts.length; i++) {
                        var rt = rts[i];
                        if (interactive && rt.className == "tr")
                            rt.style.display = "none";
                        if (backwardsCompatible) {
                            // find the text node
                            for ( j=0; j<rt.childNodes.length; j++) {
                                if (rt.childNodes[j].nodeType == 3) {
                                    var text = rt.childNodes[j].nodeValue;
                                    text = text.substring( 1, text.length-1);
                                    rt.childNodes[j].nodeValue = text;
                                }
                            }
                        }
                    }
                }
            }
            else if (navigator.appCodeName.search(/Mozilla/)!=-1 &&
                navigator.appVersion.search(/5.0/)!=-1) {
                if (interactive) {
                    for ( i=0; i<rts.length; i++)
                        rts[i].style.display = "none";
                }
                if (!backwardsCompatible) {
                    for ( i=0; i<rts.length; i++) {
                        var rt = rts[i];
                        // find the text node
                        for ( j=0; j<rt.childNodes.length; j++) {
                            if (rt.childNodes[j].nodeType == 3) {
                                var text = rt.childNodes[j].nodeValue;
                                if (rt.className == "re") {
                                    text = "《" + text + "》";
                                }
                                else {
                                    text = "{" + text + "}";
                                }
                                rt.childNodes[j].nodeValue = text;
                            }
                        }
                    }
                }
            }
        }
        else if (interactive || !backwardsCompatible) {
            // The text in the annotation <span> elements will be flattened, hopefully to one
            // text element for each text/ruby/translation.
            // If backwardsCompatible is not set, add parentheses to ruby and annotation.
            // If interactive, extract ruby and translation and store them as attribute.
            var an = document.getElementsByTagName( "span");
            for ( i=0; i<an.length; i++) {
                if (an[i].className == "an") {
                    var reading = -1;
                    var translation = -1;
                    var first = true;
                    var j=0;
                    while (j<an[i].childNodes.length) {
                        var child = an[i].childNodes[j];
                        if (child.nodeType == 3) { // text node
                            if (first) { // skip the ruby base text
                                first = false;
                            }
                            else {
                                var text = child.nodeValue;
                                if (!backwardsCompatible) {
                                    if (reading == -1) {
                                        text = "《" + text + "》";
                                    }
                                    else {
                                        text = "{" + text + "}";
                                    }
                                    if (!interactive) // otherwise node will be removed anyway
                                        an[i].replaceChild( document.createTextNode( text),
                                                            child);
                                }
                                if (reading == -1)
                                    reading = text;
                                else
                                    translation = text;
                                if (interactive) {
                                    an[i].removeChild( child);
                                    continue;
                                }
                            }
                        }
                        j++;
                    }
                    if (reading != -1)
                        an[i].setAttribute( "reading", reading);
                    if (translation != -1)
                        an[i].setAttribute( "translation", translation);
                }
            }
        }
    }
}

function sp( el) {
    if (el.style)
        el.style.color = "blue";

    if (el.getElementsByTagName) {
        // show floating window with annotation
        // calculate position of element
        var posX = 0;
        var posY = 0;
        var width = el.offsetWidth;
        var height = el.offsetHeight;
        var e = el;
        while (e!=null && el!=window.document) {
            posX += e.offsetLeft;
            posY += e.offsetTop;
            e = e.offsetParent;
        }
        
        var reading = "";
        var translation = "";
        
        var rts = el.getElementsByTagName( "rt");
        if (rts.length > 0) {
            for ( i=0; i<rts.length; i++) {
                var rt = rts[i];
                for ( j=0; j<rt.childNodes.length; j++) {
                    if (rt.childNodes[j].nodeType == 3) {
                        var text = rt.childNodes[j].nodeValue;
                        if (rt.className == "re")
                            reading = text;
                        else
                            translation = text;
                    }
                }
            }
        }
        else if (el.getAttribute( "reading") != "" ||
                 el.getAttribute( "translation") != "") {
            reading = el.getAttribute( "reading");
            translation = el.getAttribute( "translation");
        }

        if (reading.length>0 && reading.charAt( 0) == "《")
            reading = reading.substring( 1, reading.length-1);
        if (translation.length>0 && translation.charAt( 0) == "{")
            translation = translation.substring( 1, translation.length-1);
        if (reading_popup && reading_popup.style) {
            reading_popup_text.nodeValue = reading;
            reading_popup.style.left = posX;
            reading_popup.style.top = posY - el.offsetHeight*0.7; // font-size of reading is 70%
            if (reading_popup.style.top < 0)
                reading_popup.style.top = 0;
            reading_popup.style.display = "inline";
            translation_popup_text.nodeValue = translation;
            translation_popup.style.left = posX;
            translation_popup.style.top = posY + el.offsetHeight + 2;
            translation_popup.style.display = "inline";
        }

        var status = reading;
        if (status.length > 0)
            status += " ";
        status += translation;
        window.status = status;
    }
}

function hp( el) {
    if (el.style)
        el.style.color = el.parentNode.style.color;

    // hide popup
    if (reading_popup && reading_popup.style) {
        reading_popup.style.display = "none";
        translation_popup.style.display = "none";
    }
}

// toggle annotation shown/hidden in interactive mode
function tp( el) {
    if (el.getElementsByTagName) {
        var rts = el.getElementsByTagName( "rt");
        if (rts.length > 0) {
            for ( i=0; i<rts.length; i++) {
                var rt = rts[i];
		// if the browser supports ruby display, only translations are toggled
                if (!rubySupported || rt.className=="tr") {
                    if (rt.style.display != "inline") {
                        rt.style.display = "inline";
                    }
                    else {
                        rt.style.display = "none";
                        hp( el);
                    }
                }
            }
        }
        else if (el.getAttribute( "reading") != "" ||
                 el.getAttribute( "translation") != "") {
            // el has only textNode children. The second stores the annotation
            var first = true;
            var hadAnnotation = false;
            var i = 0;
            while (i < el.childNodes.length) {
                if (el.childNodes[i].nodeType == 3) {
                    if (first) {
                        first = false;
                    }
                    else {
                        hadAnnotation = true;
                        el.removeChild( el.childNodes[i]);
                        break;
                    }
                }
                i++;
            }
            // We want to toggle the display of the annotation, so add the annotation if it
            // was not removed.
            if (!hadAnnotation) {
                el.appendChild( document.createTextNode( el.getAttribute( "reading")+
                                                         el.getAttribute( "translation")));
            }
        }
    }
}

//-->
</SCRIPT>


<!-- end of JGloss embedded file -->
